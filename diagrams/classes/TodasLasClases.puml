@startuml TODAS LAS CLASES

'<Modelo

'<CriterioDeVictoria

interface CriterioDeVictoria{
    + establecerJugadores(jugadores:List<Jugador>)
    + jugadoresOrdenados():List<Jugador> 
    + terminoJuego(rondasJugadas:int):boolean
}

class MejorPuntaje implements CriterioDeVictoria {
    - limitePuntos:int
    - limiteRondas:int
    ~ listaOrdenadaJugadores:List<Jugador>

    + MejorPuntaje(limiteRondas:int,limitePuntos:int)
    + jugadoresOrdenados():List<Jugador>
    - ordenarLista()
    + establecerJugadores(jugadores:List<Jugador>)
    + terminoJuego(rondasJugadas:int):boolean
}

'CriterioDeVictoria/>

'<Excepciones

exception ArchivoInexistenteException {}
exception CantidadDeJugadoresMenorADosException {}
exception ModificadorInexistenteException {}
exception ModificadorInvalidoException {}
exception OpcionesDeTamanioInvalidoException {}
exception OpcionesIncorrectasException {}
exception OpcionesInexistentesException {}
exception PreguntaInexistenteException {}

'Excepciones/>

'<Fabricas

class FabricaJugadores{
    + {static} crearListaJugadores(jugadores:List<String>):List<Jugador>
}

class FabricaManejador{
    + {static} crearManejador(pregunta:Pregunta):Manejador
}

class FabricaModificadores{
    + {static} crearListaModificadores():List<Modificador>
}

class FabricaOpciones{
    + {static} crearListaGrupo(grupos:List<String>,contenidoOpciones:List<String>,posicionesCorrectas:List<String>,estadoIndicado:Estado):List<Grupal>
    + {static} crearListaOrdenada(contenidoOpciones:List<String>,ordenCorrecto:List<String>,estadoIndicado:Estado):List<Ordenada>
    + {static} crearListaSimple(contenidoOpciones:List<String>,posicionesDeCorrectas:List<String>,estado:Estado):List<Simple>
}

class FabricaPreguntas{
    + {static} obtenerCantidadCorrectas(preguntaJson:JSONObject):int
    + {static} crearPreguntaVerdaderoFalso(enunciado:String, opciones:List<Simple>, puntaje:Puntaje, categoria:String, explicacion:String):VerdaderoFalso
    + {static} crearPreguntaMultipleChoice(enunciado:String, opciones:List<Simple>, puntaje:Puntaje, categoria:String, explicacion:String):MultipleChoice
    + {static} crearPreguntaOrderedChoice(enunciado:String, opciones:List<Ordenada>, puntaje:Puntaje, categoria:String, explicacion:String):OrderedChoice
    + {static} crearPreguntaGroupChoice(enunciado:String, opciones:List<Grupal>, puntaje:Puntaje, categoria:String, explicacion:String):GroupChoice
}

'Fabricas/>

'<Jugador

class Jugador{
    - puntaje:int;
    - nombre:String;
    - modificadores:List<Modificador>;
    - ultimoModificadorUsado:Modificador;

    + Jugador(nombre:String, modificadores:List<Modificador>)

    - establecerDuenioModificadores()
    + sumarPuntaje(puntaje:int)
    + obtenerPuntaje():int
    + tieneMejorPuntajeQue(jugador:Jugador):boolean
    + usar(modificador:Modificador)
    + obtenerModificadores():List<Modificador>
    + tieneNombre(buscado:String):boolean
    + equals(jugador:Jugador):boolean
    + obtenerNombre():String
    + obtenerUltimoModificadorUsado():Modificador
}

'Jugador/>

'<Lector

'<Mezclador

interface Mezclador {
    + mezclarPreguntas(preguntas:List<Pregunta>):List<Pregunta>
}

class MezclaNula implements Mezclador{
    + mezclarPreguntas(preguntas:List<Pregunta>):List<Pregunta>
}

class MezclaSinRepetirCategoria implements Mezclador{
    + mezclarPreguntas(preguntas:List<Pregunta>):List<Pregunta>
}

'Mezclador/>

class Lector{
    + {static} obtenerPreguntasDeJson(mezclador:Mezclador, direccion:String):List<Pregunta>
}

abstract class LectorParser{
    ~ enunciado:String
    ~ categoria:String
    ~ explicacion:String

    + {abstract} parsearPregunta(preguntaJson:JSONObject, puntaje:Puntaje):Pregunta

    ~ leerEnunciadoCategoriaYExplicacion(preguntaJson:JSONObject)
    ~ obtenerContenidoOpciones(preguntaJson:JSONObject, cantidadOpciones:int):List<String>
}

class ParserGroup extends LectorParser{
    + parsearPregunta(preguntaJson:JSONObject, puntaje:Puntaje):Pregunta
}
class ParserMChoice extends LectorParser{
    + parsearPregunta(preguntaJson:JSONObject, puntaje:Puntaje):Pregunta
}
class ParserOrdered extends LectorParser{
    + parsearPregunta(preguntaJson:JSONObject, puntaje:Puntaje):Pregunta
}
class ParserVoF extends LectorParser{
    + parsearPregunta(preguntaJson:JSONObject, puntaje:Puntaje):Pregunta
}

'Lector/>

'<Modificador

abstract class Modificador implements Usable{
    # duenio:Jugador
    # siguiente:Modificador

    + modificarPuntajes(respuestas:List<Respuesta>)
    + {abstract} establecerDuenio(jugadorActivo:Jugador)
    + {abstract} agregarModificador(modificador:Modificador)
    + actualizar(List<Modificador> modificadores):Modificador 
    + mostrarModificador():String
    + usableConPenalidad():boolean
    + usableSinPenalidad():boolean
}

class Anulador extends Modificador{
    - factorDeMultiplicacion:int
    - llamados:int

    ~ aplicarModificador(respuestas:List<Respuesta>)
    + establecerDuenio(jugadorActivo:Jugador)
    + agregarModificador(modificador:Modificador)
    - boolean esIgual(modificador:Modificador)
}

class Exclusividad extends Modificador{
    - llamados:int
    - factorDeMultiplicacion:int

    ~ aplicarModificador(respuestas:List<Respuesta>)
    + establecerDuenio(jugadorActivo:Jugador)
    + agregarModificador(modificador:Modificador)
    - esIgual(modificador:Modificador):boolean 
    + usableConPenalidad():boolean
}

class Multiplicador extends Modificador{
    - factorDeMultiplicacion:int

    + Multiplicador(factorDeMultiplicacion:int)
    ~ aplicarModificador(respuestas:List<Respuesta>)
    + establecerDuenio(jugadorActivo:Jugador)
    + boolean tieneFactor(factorDeMultiplicacion:int)
    + agregarModificador(modificador:Modificador)
    + mostrarModificador():String
    + usableSinPenalidad():boolean
}

class Nulo extends Modificador{
    + modificarPuntajes(respuestas:List<Respuesta>)
    ~ aplicarModificador(respuestas:List<Respuesta>)
    + establecerDuenio(jugadorActivo:Jugador)
    + agregarModificador(modificador:Modificador)
    + actualizar(modificadores:List<Modificador>):Modificador
    + mostrarModificador():String
}

interface Usable{
    + usableConPenalidad():boolean
    + usableSinPenalidad():boolean
}

'Modificador/>

'<Opcion

'<Estado

abstract class Estado {
    + contarCorrecta():int
    + contarIncorrecta():int
}

class Correcta extends Estado{
    + contarCorrecta():int
}
class Incorrecta extends Estado{
    + contarIncorrecta():int
}

'Estado/>

abstract class Opcion{
    ~ texto:String
    
    + Opcion(texto:String, estado:Estado)
    + {abstract} contarCorrecta():int
    + {abstract} contarIncorrecta():int
    + obtenerTexto():String
}

class Grupal extends Opcion{
    - nombreGrupo:String
    - int puntosCorrecta:int
    - int puntosIncorrecta:int

    + Grupal(texto:String, nombreGrupo:String, estado:Estado)
    + actualizarEstado(opcion:Grupal)
    + obtenerGrupo():String
    + int contarCorrecta():int
    + int contarIncorrecta():int
}
class Ordenada extends Opcion{
    - posicion:int
    - puntosIncorrecta:int
    - puntosCorrecta:int

    + Ordenada(texto:String, posicion:int, estado:Estado)
    + actualizarEstado(opcion:Ordenada)
    + contarCorrecta():int
    + contarIncorrecta():int
}
class Simple extends Opcion{
    - estado:Estado

    + Simple(texto:String, estado:Estado)
    + contarCorrecta():int
    + contarIncorrecta():int
    + actualizarEstado(opcion:Simple)
    + tieneIgualTexto(opcionJugador:Simple):boolean
}

'Opcion/>

'<Pregunta

abstract class Pregunta{
    ~ categoria:String
    ~ enunciado:String
    ~ explicacion:String
    ~ puntaje:Puntaje

    + Pregunta(enunciado:String, puntaje:Puntaje, categoria:String, explicacion:String)

    + asignarPuntajes(respuestas:List<Respuesta>)
    + modificadorEsValido(modificador:Modificador):boolean
    + obtenerCategoria():String
    + obtenerEnunciado():String
    + obtenerExplicacion():String
}

class GroupChoice extends Pregunta{
    - opciones:List<Grupal>

    + GroupChoice(enunciado:String, List<Grupal> opciones, puntaje:Puntaje, categoria:String, explicacion:String)
    + obtenerOpciones():List<Grupal>
    + validarOpciones(opcionesJugador:List<Opcion>)
    ~ validarTamanioOpciones(opcionesJugador:List<Opcion>)
}

class MultipleChoice extends Pregunta{
    - opciones:List<Simple>

    + MultipleChoice(enunciado:String, opciones:List<Simple>, puntaje:Puntaje, categoria:String, explicacion:String)
    + obtenerOpciones():List<Simple>
    + validarOpciones(opcionesJugador:List<Opcion>)
    ~ validarTamanioOpciones(opcionesJugador:List<Opcion>)
}

class OrderedChoice extends Pregunta{
    - opciones:List<Ordenada>

    + OrderedChoice(enunciado:String, opciones:List<Ordenada>, puntaje:Puntaje, categoria:String, explicacion:String)
    + obtenerOpciones():List<Ordenada>
    + validarOpciones(opcionesJugador:List<Opcion>)
    ~ validarTamanioOpciones(opcionesJugador:List<Opcion>)
}

class VerdaderoFalso extends Pregunta{
    - opciones:List<Simple>

    + VerdaderoFalso(enunciado:String, opciones:List<Simple>, puntaje:Puntaje, categoria:String, explicacion:String)
    + obtenerOpciones():List<Simple>
    + validarOpciones(opcionesJugador:List<Opcion>)
    ~ validarTamanioOpciones(opcionesJugador:List<Opcion>)
}

'Pregunta/>

'<Puntaje

abstract class Puntaje{
    ~ puntaje:int

    + {abstract} asignarPuntaje(respuesta:Respuesta)
    + asignarPuntajes(respuestas:List<Respuesta>)
    + {abstract} modificadorEsValido(modificador:Modificador):boolean
}

class Clasica extends Puntaje{
    ~ cantidadCorrectasEsperada:int

    + Clasica(cantidadCorrectasPregunta:int)
    + asignarPuntaje(respuesta:Respuesta)
    + modificadorEsValido(modificador:Modificador):boolean
}

class ConPenalidad extends Puntaje{
    ~ puntajeIncorrecta:int

    + asignarPuntaje(respuesta:Respuesta)
    + modificadorEsValido(modificador:Modificador):boolean
}

class Parcial extends Puntaje{
    + asignarPuntaje(respuesta:Respuesta)
    + modificadorEsValido(modificador:Modificador):boolean
}

'Puntaje/>

'<Respuesta

class Respuesta{
    - opciones:List<Opcion>
    - jugador:Jugador
    - puntaje:int

    + Respuesta(opciones:List<Opcion>, jugador:Jugador)
    + asignarPuntaje(puntaje:int)
    + obtenerOpciones():List<Opcion>
    + obtenerPuntaje():int
    + multiplicarPuntaje(valor:int)
    + esCorrecta():boolean
    + sumarPuntaje()
    + boolean perteneceA(jugador:Jugador)
}

'Respuesta/>

'<Turno

class Turno{
    - respuestas:List<Respuesta>
    - preguntaDelTurno:Pregunta
    - modificador:Modificador

    + agregarRespuesta(opcionesJugador:List<Opcion>, jugador:Jugador, modificador:Modificador)
    + asignarPuntajes()
    + reiniciarTurno(pregunta:Pregunta, manejador:Manejador)
    + cantidadDeRespuestas():int
}

'Turno/>

class AlgoHoot3{
    - preguntas:List<Pregunta>
    - jugadores:List<Jugador>
    - turno:Turno
    - {static} instancia:AlgoHoot3
    - rondas:int
    - iteradorJugadores:Iterator<Jugador>
    - jugadorActual:Jugador
    - criterio:CriterioDeVictoria

    + {static} obtenerInstancia():AlgoHoot3

    + iniciarAlgoHoot(jugadores:List<Jugador>, turno:Turno, criterio:CriterioDeVictoria, preguntas:List<Pregunta>)
    + pasarRonda()
    + jugarTurno(opcionesElegidas:List<Opcion>, modificador:Modificador)
    + terminoLaRonda():boolean
    + obtenerRonda():int
    + obtenerPreguntaDeRondaActual():Pregunta
    + asignarPuntajes()
    + obtenerJugadorActual():Jugador
    + terminoJuego():boolean
    + jugadoresOrdenadosPorCriterio():List<Jugador>
}

'Modelo/>

'<RELACIONES

'RELACIONES/>