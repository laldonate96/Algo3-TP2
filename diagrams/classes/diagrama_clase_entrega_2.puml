@startuml diagrama de clases
skinparam classAttributeIconSize 0
title Diagrama de clases

class Jugador{
    - nombre: String
    - puntaje: int
    - modificadores: List<ModificadorPuntaje>
    ---
    + Jugador(nombre: String, modificadores: List<Modificador>)
    + sumarPuntaje(puntaje: int)
    + obtenerPuntaje(): int
    + responder(opciones: List<Opcion>, opcionesPregunta: List<Opcion>, modificador: Modificador)
}

abstract class ModificadorPuntaje {
    -usos: int
    ----
    + modificarPuntaje(puntaje: int): int
    + usar()
    + equals(modificador: Modificador): Bool
    + actualizar(modificadores: List<ModificadorPuntaje>)
}

class Multiplicador extends ModificadorPuntaje {
    - factorDeMultiplicacion: int
    ---
    + Multiplicador(factor: int)
    + modificarPuntaje(puntaje: int): int
    + equals(modificadorPuntaje: ModificadorPuntaje): Bool
    + equals(multiplicador: Multiplicador): Bool
}

class NuloPuntaje extends ModificadorPuntaje {
    ---
    + Nulo()
    + modificarPuntaje(puntaje: int): int
    + usar()
    + equals(modificador: Modificador): Bool
    + actualizar(modificadores: List<ModificadorPuntaje>)
}

class ExclusividadPuntaje extends ModificadorPuntaje {
    ---
    + ExclusividadPuntaje()
    + equals(modificadorPuntaje: ModificadorPuntaje): Bool
    + equals(exlusividad: ExclusividadPuntaje): Bool
    + modificarPuntaje(puntaje: int): int
}

class AnuladorPuntaje extends ModificadorPuntaje {
    ---
    + AnuladorPuntaje()
    + equals(modificadorPuntaje: ModificadorPuntaje): Bool
    + equals(anulador: AnuladorPuntaje): Bool
    + modificarPuntaje(puntaje: int): int
}

interface ModificadorTurno{
    ---
    + modificarPuntajes(respuestas: List<Respuesta> )
    + usar(modificadorPuntaje: ModificadorPuntaje , jugadorActivo: Jugador)
}

class AnuladorTurno implements ModificadorTurno{
    - modificadorReferencia: ModificadorPuntaje
    - cantidadDeCorrectas: int
    - jugadoresProtegidos: List<Jugador>
    -factorDeMultiplicacion: int
    ---
    + AnuladorTurno( modificadorReferencia: ModificadorPuntaje)
    + modificarPuntajes(respuestas: List<Respuesta>)
    + usarModificador( jugadorActivo: Jugador)
    + usar(modificadorPuntaje: ModificadorPuntaje, jugadorActivo: Jugador)
}

class ExclusividadTurno implements ModificadorTurno{
    - modificadorDeReferencia: ModificadorPuntaje
    - llamados: int
    - cantidadDeCorrectas: int
    -factorDeMultiplicacion: int
    ---
    + ExclusividadTurno(modificadorDereferencia: ModificadorPuntaje)
    + modificarPuntajes(respuestas: List<Respuesta>)
    + usarModificador()
    + usar(modificadorPuntaje: ModificadorPuntaje, jugadorActivo: Jugador)
}

class NuloTurno implements ModificadorTurno{
    ---
    + modificarPuntajes(respuestas: List<Respuesta>)
    + usar(modificadorPuntaje: ModificadorPuntaje, jugadorActivo: Jugador)
}

class Respuesta {
    - opciones: List<Opcion>
    - jugador: Jugador
    -puntaje: int
    - modificador: ModificadorPuntaje
    ---
    + asignarPuntaje(puntaje:int)
    + obtenerPuntaje(): int
    + Respuesta(opciones: List<Opcion>,jugador: Jugador, modificadorPuntaje: ModificadorPuntaje )
    + sumarPuntaje(puntaje: int)
    + obtenerOpciones(): List<Opcion>
    + multiplicarPuntaje(valor:int)
    + esCorrecta(): boolean
    + sumarPuntaje()
    + perteneceA(jugador: Jugador ):boolean
}

 abstract class Puntaje {
     # puntaje: int
     + asignarPuntaje(respuesta: Respuesta)
}

class Clasica extends Puntaje{
     + Clasica([super])
     + asignarPuntaje(respuesta: Respuesta)
}

class ConPenalidad extends Puntaje{
     + ConPenalidad([super])
     + asignarPuntaje(respuesta: Respuesta)
}

class Parcial extends Puntaje{
    + Parcial([super])
    +asignarPuntaje(respuesta: Respuesta)
}


abstract class Pregunta {
    # enunciado: String
    # opciones: List<Opcion>
    # puntaje: Puntaje
    ---
    + Pregunta(enunciado: String, opciones: List<Opcion>, puntaje: Puntaje )
    + asignarPuntajes(respuestas: List<Respuesta>)
}


abstract class Opcion {
    #texto: String
    #estado: Estado
    #equals(opcion: Opcion): Bool
    ---
    +Opcion(texto: String, estado: Estado)
    +equals(opcion: Opcion): Bool
    +actualizarEstado(Opcion opcion)
    +contarCorrecta():int
    +contarIncorrecta():int
    +obtenerTexto(): String
}

class Ordenada extends Opcion {
    -posicion: int
    ---
    +Ordered([super], posicion: int)
    +obtenerPosicion(): int
}

class Simple extends Opcion {
    +Simple([super])
}

class Grupo extends Opcion {
    -nombreGrupo: String
    ---
    +Grupo([super], nombreGrupo: String)
    +obtenerGrupo(): String
}

interface Estado {
    + esCorrecta()
}

class Correcta implements Estado {
    + esCorrecta()
}

class Incorrecta implements Estado {
    + esCorrecta()
}

class Turno {
    - turno :Int
    - respuestasPorTurno <Jugador>
    - preguntaDelTurno: Pregunta
    - modificadoresUsados<Modificador>
    - usarModificador(modificador :Modificador)
    ---
    + {static} Turno()
    + asignarPreguntaDelTurno(pregunta :Pregunta)
    + responderPorTurno(respuestasPorTurno<Respuestas>)
}


Turno "1" o-- "*" Jugador
Turno "1" o-down "0..*" ModificadorTurno
Turno *-l- Pregunta
Jugador "1" <-d- Respuesta
Respuesta .l.> Pregunta
Puntaje .u.> Respuesta
Opcion *-r- Estado
Respuesta -> Opcion:"1..*"
Respuesta -left-> ModificadorPuntaje
@enduml